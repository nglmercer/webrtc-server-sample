import{w as E,v as W}from"./runtime-dom.esm-bundler.Bg557htM.js";import{c as l,a as S,b as x,d as R}from"./store.DiYwYFjM.js";import{B as A,l as s,u as P,a as k,b as N}from"./index.C1EMOFIg.js";import{a as F}from"./apiConfig.nx_Al2Mg.js";import{_ as K}from"./_plugin-vue_export-helper.DlAUqK2U.js";import{d as j,c as O,o as D,a as d,t as w,n as $,F as H,i as L,O as q,r as _,f as z,g as B,M as J,N as V}from"./runtime-core.esm-bundler.DFbp6Gf0.js";class Y extends A{constructor(e){super(e)}setupPeerConnection(e,t){console.log(`[DataWebRTC] Configurando conexión de datos para ${e}`),t.onsignalingstatechange=()=>{console.log(`[DataWebRTC] ${e} - Estado de señalización: ${t.signalingState}`)}}async createOffer(e){const t=this.getSignalingState(e);if(t&&t!=="stable"){console.log(`[DataWebRTC] No se puede crear oferta para ${e}, estado: ${t}`);return}try{await super.createOffer(e),console.log(`[DataWebRTC] ✅ Oferta creada para ${e}`)}catch(n){throw console.error(`[DataWebRTC] ❌ Error creando oferta para ${e}:`,n),n}}async handleOffer(e,t){const n=this.getSignalingState(e);if(n==="closed"){console.log(`[DataWebRTC] Ignorando oferta para ${e} - conexión cerrada`);return}if(n==="have-local-offer"){console.log(`[DataWebRTC] Colisión detectada con ${e} - tenemos oferta local`);const i=this.peers.get(e);if(i)try{await i.connection.setLocalDescription({type:"rollback"}),console.log(`[DataWebRTC] Rollback exitoso para ${e}`)}catch(b){console.error(`[DataWebRTC] Error en rollback para ${e}:`,b),this.closeConnection(e);return}}if(n==="have-remote-offer"){console.log(`[DataWebRTC] Ignorando oferta duplicada para ${e} - ya tenemos oferta remota`);return}try{this.peers.get(e)||(console.log(`[DataWebRTC] Creando nueva conexión para procesar oferta de ${e}`),this.getPeerConnection(e,!0)),await super.handleOffer(e,t),console.log(`[DataWebRTC] ✅ Oferta procesada de ${e}`)}catch(i){throw console.error(`[DataWebRTC] ❌ Error manejando oferta de ${e}:`,i),i instanceof Error&&i.message.includes("InvalidStateError")&&(console.log(`[DataWebRTC] Error de estado detectado, limpiando conexión con ${e}`),this.closeConnection(e)),i}}async handleAnswer(e,t){const n=this.getSignalingState(e);if(n==="closed"){console.log(`[DataWebRTC] Ignorando answer para ${e} - conexión cerrada`);return}if(n!=="have-local-offer"){console.log(`[DataWebRTC] Ignorando answer de ${e} - estado: ${n}`);return}try{await super.handleAnswer(e,t),console.log(`[DataWebRTC] ✅ Answer establecida correctamente para ${e}`)}catch(i){throw console.error(`[DataWebRTC] ❌ Error manejando answer de ${e}:`,i),i instanceof Error&&i.message.includes("InvalidStateError")&&this.closeConnection(e),i}}sendChatMessage(e,t){e==="broadcast"?this.broadcastMessage(t):this.sendMessageToPeer(e,t)}sendPrivateMessage(e,t){this.sendMessageToPeer(e,JSON.stringify({type:"private",message:t,timestamp:Date.now()}))}async forceRenegotiation(e){console.log(`[DataWebRTC] Forzando renegociación con ${e}`),this.closeConnection(e),await new Promise(t=>setTimeout(t,1e3)),await this.createOffer(e)}}class G{localUserId;config;pendingOffers=new Set;connectionAttempts=new Map;lastOfferTime=new Map;constructor(e){this.localUserId=e.localUserId,this.config=e}shouldInitiateOffer(e){return this.localUserId.localeCompare(e)<0}isOwnMessage(e){return e===this.localUserId}getProgressiveDelay(e){return 100+(this.connectionAttempts.get(e)||0)*200+Math.random()*100}incrementAttempts(e){const t=this.connectionAttempts.get(e)||0;this.connectionAttempts.set(e,t+1)}resetAttempts(e){this.connectionAttempts.delete(e)}async handleNewParticipationRequest(e){if(this.isOwnMessage(e)){console.log("[Signaling] Ignorando nuestra propia solicitud de participación");return}if(console.log(`[Signaling] Nueva solicitud de participación de: ${e}`),this.pendingOffers.has(e)){console.log(`[Signaling] Ya hay una oferta pendiente con ${e}`);return}if(this.shouldInitiateOffer(e)){console.log(`[Signaling] Nosotros (${this.localUserId}) iniciamos la oferta a ${e}`);const t=this.getProgressiveDelay(e);await new Promise(n=>setTimeout(n,t)),this.pendingOffers.add(e),this.lastOfferTime.set(e,Date.now()),this.incrementAttempts(e);try{await this.config.onShouldCreateOffer(e)}catch(n){console.error(`[Signaling] Error creando oferta para ${e}:`,n),this.pendingOffers.delete(e)}}else console.log(`[Signaling] Esperando oferta de ${e} (ellos inician)`)}async handleIncomingOffer(e,t){if(this.isOwnMessage(e)){console.log("[Signaling] Ignorando nuestra propia oferta");return}if(console.log(`[Signaling] Oferta recibida de: ${e}`),this.pendingOffers.has(e)){const n=this.lastOfferTime.get(e)||0,i=Date.now()-n;if(console.log(`[Signaling] Colisión detectada con ${e} (${i}ms desde nuestra oferta)`),this.localUserId.localeCompare(e)>0)console.log("[Signaling] Hacemos rollback (nuestro ID es mayor)"),this.pendingOffers.delete(e);else{console.log("[Signaling] Ignoramos oferta entrante (nuestro ID es menor)");return}}try{await this.config.onShouldHandleOffer(e,t),this.resetAttempts(e)}catch(n){console.error(`[Signaling] Error manejando oferta de ${e}:`,n)}}async handleIncomingAnswer(e,t){if(this.isOwnMessage(e)){console.log("[Signaling] Ignorando nuestra propia respuesta");return}if(console.log(`[Signaling] Respuesta recibida de: ${e}`),!this.pendingOffers.has(e)){console.warn(`[Signaling] Respuesta inesperada de ${e} (no hay oferta pendiente)`);return}this.pendingOffers.delete(e);try{await this.config.onShouldHandleAnswer(e,t),this.resetAttempts(e),console.log(`[Signaling] ✅ Conexión establecida con ${e}`)}catch(n){console.error(`[Signaling] Error manejando respuesta de ${e}:`,n)}}async handleIncomingCandidate(e,t){this.isOwnMessage(e)||await this.config.onShouldHandleCandidate(e,t)}async handleUserConnected(e){if(this.isOwnMessage(e)){console.log("[Signaling] Ignorando nuestra propia conexión");return}if(console.log(`[Signaling] Usuario conectado: ${e}`),this.shouldInitiateOffer(e)){console.log(`[Signaling] Iniciando conexión WebRTC con ${e}`);const t=this.getProgressiveDelay(e);await new Promise(n=>setTimeout(n,t)),this.pendingOffers.add(e),this.lastOfferTime.set(e,Date.now()),this.incrementAttempts(e);try{await this.config.onShouldCreateOffer(e)}catch(n){console.error(`[Signaling] Error iniciando conexión con ${e}:`,n),this.pendingOffers.delete(e)}}else console.log(`[Signaling] Esperando que ${e} inicie la conexión`)}handleUserDisconnected(e){console.log(`[Signaling] Usuario desconectado: ${e}`),this.pendingOffers.delete(e),this.connectionAttempts.delete(e),this.lastOfferTime.delete(e)}cleanupPeer(e){this.pendingOffers.delete(e),this.connectionAttempts.delete(e),this.lastOfferTime.delete(e)}}const Q=j({__name:"chat",setup(m,{expose:e}){e();const t=new URLSearchParams(window.location.search),n=t.get("userId"),i=t.get("roomId");(!n||!i)&&s.error("userId o roomId no proporcionados en la URL. Redirigiendo...");const b=P(l),c=_(""),C=_(null);let g,h,f;z(()=>{s.info(`Componente montado. Iniciando chat para userId: ${n} en roomId: ${i}`),l.setKey("roomId",i),l.setKey("myId",n),l.setKey("status","Inicializando..."),l.setKey("peers",{}),l.setKey("messages",[]);const p={onSignalNeeded:(a,o)=>{s.signalingDebug(`DataWebRTC -> onSignalNeeded para ${a}. Enviando señal...`,o),h.sendSignal(a,o)},onDataChannelMessage:(a,o)=>{s.webrtcDebug(`DataWebRTC -> onDataChannelMessage de ${a}: ${o}`);try{const r=JSON.parse(o);R({...r,timestamp:Date.now()})}catch(r){s.error("Error al parsear mensaje JSON:",r)}},onConnectionStateChange:(a,o)=>{s.webrtcInfo(`DataWebRTC -> onConnectionStateChange para ${a}: ${o}`),o==="connected"?(x(a,{status:"connected"}),l.setKey("status",`Conectado a ${a}.`),f.cleanupPeer(a)):["disconnected","failed","closed"].includes(o)&&b.value.peers[a]?.status!=="disconnected"&&(s.warn(`Conexión con ${a} perdida. Estado: ${o}. Limpiando...`),l.setKey("status",`Conexión con ${a} perdida.`),g.closeConnection(a),S(a),f.handleUserDisconnected(a))},onPeerDisconnected:a=>{s.warn(`Peer ${a} desconectado completamente`),S(a),f.handleUserDisconnected(a)}};g=new Y(p),f=new G({localUserId:n,onShouldCreateOffer:async a=>{await g.createOffer(a)},onShouldHandleOffer:async(a,o)=>{await g.handleOffer(a,o)},onShouldHandleAnswer:async(a,o)=>{await g.handleAnswer(a,o)},onShouldHandleCandidate:async(a,o)=>{await g.addIceCandidate(a,o)}});const y=F.getFullUrl();s.debug(`Creando SignalingChannel para conectar a: ${y}`),k(y),h=N({userId:n,roomId:i},{onConnect:()=>{s.signalingInfo("Signaling -> onConnect: ¡Conectado al servidor de señalización!"),l.setKey("isConnected",!0),l.setKey("status","Conectado. Verificando sala..."),s.debug("Signaling: Enviando 'check-presence' al servidor."),h.checkPresence(a=>{s.debug(`Signaling: Respuesta de 'check-presence'. La sala existe: ${a}`);const o=!a;l.setKey("isInitiator",o),s.debug(`Signaling: Soy el iniciador: ${o}. Intentando unirse/crear sala.`),h.openOrJoinRoom(o,r=>{if(s.debug("Signaling: Respuesta de 'open-or-join-room':",r),r){const u=o?"Sala creada. Esperando a otros...":"Unido a la sala. Enviando solicitud de conexión...";l.setKey("status",u),s.debug("Respuesta completa del servidor:",r),s.debug(`¿No es iniciador?: ${!o}`),o?s.info("Somos el iniciador. Esperando que otros usuarios se unan..."):(s.info("No somos el iniciador. Enviando solicitud de participación a la sala..."),setTimeout(()=>{h.sendNewParticipationRequest(i)},1e3))}else{const u="Error al unirse a la sala";s.error(`Signaling: ${u}`,r),l.setKey("status",u)}})})},onDisconnect:()=>{s.signalingError("Signaling -> onDisconnect: ¡Desconectado del servidor de señalización!"),l.setKey("isConnected",!1),l.setKey("status","Desconectado del servidor. Intenta recargar."),g.closeAllConnections()},onMessage:async({extra:a,message:o})=>{const r=o.sender;if(s.signalingDebug(`Signaling -> onMessage: Mensaje recibido de ${r}`,o),o.newParticipationRequest)s.info(`Manejando 'newParticipationRequest' de ${r}`),l.setKey("status",`Conectando con ${r}...`),x(r,{status:"negotiating"}),await f.handleNewParticipationRequest(r);else if(o.isWebRTCSignal){s.info(`Manejando 'isWebRTCSignal' de ${r}`,o);const{signal:u}=o;u.type==="offer"?(s.debug("...es una oferta (offer)."),x(r,{status:"negotiating"}),await f.handleIncomingOffer(r,u)):u.type==="answer"?(s.debug("...es una respuesta (answer)."),await f.handleIncomingAnswer(r,u)):u.candidate?(s.debug("...es un candidato ICE."),await f.handleIncomingCandidate(r,u.candidate)):s.warn("Señal WebRTC desconocida:",u)}},onUserDisconnected:a=>{b.value.peers[a]&&(s.warn(`Signaling -> onUserDisconnected: Usuario ${a} se ha desconectado.`),l.setKey("status",`Usuario ${a} se fue.`),g.closeConnection(a),S(a),f.handleUserDisconnected(a))},onRoomOwnerChanged:a=>{s.info(`Signaling -> onRoomOwnerChanged: El nuevo dueño es ${a}`);const o=a===n;l.setKey("isInitiator",o),o&&l.setKey("status","¡Ahora eres el dueño de la sala!")}}),s.debug("Llamando a signaling.connect()..."),h.connect();const{socket:T}=h;T&&T.on("user-connected",async a=>{s.info(`Nuevo usuario conectado: ${a}`),await f.handleUserConnected(a)})}),B(()=>{s.warn("Componente desmontado. Cerrando todas las conexiones."),g.closeAllConnections(),h&&h.disconnect()});function M(){if(!c.value.trim()||Object.keys(b.value.peers).length===0)return;const p={senderId:n,senderName:n,text:c.value.trim()},y=JSON.stringify(p);R({...p,timestamp:Date.now()}),g.sendChatMessage("broadcast",y),c.value=""}J(()=>b.value.messages,async()=>{await V(),C.value&&(C.value.scrollTop=C.value.scrollHeight)},{deep:!0});const v={params:t,userId:n,roomId:i,state:b,newMessage:c,messagesContainer:C,get webrtc(){return g},set webrtc(p){g=p},get signaling(){return h},set signaling(p){h=p},get signalingHandler(){return f},set signalingHandler(p){f=p},sendMessage:M};return Object.defineProperty(v,"__isScriptSetup",{enumerable:!1,value:!0}),v}}),X={class:"flex flex-col h-screen max-w-4xl mx-auto p-4"},Z={class:"p-4 border-b border-gray-700"},U={class:"text-xl font-bold"},I={class:"text-sm text-gray-400"},ee={class:"text-xs text-gray-500 mt-2"},ne={ref:"messagesContainer",class:"flex-grow p-4 overflow-y-auto space-y-4 bg-gray-800/50 rounded-md my-4"},ae={class:"font-bold text-sm"},te={class:"text-white break-words"},oe={class:"text-xs text-gray-400 text-right mt-1"},se={class:"p-4 border-t border-gray-700"},ie=["disabled"],re=["disabled"];function le(m,e,t,n,i,b){return D(),O("div",X,[d("header",Z,[d("h1",U,"Sala: "+w(n.state.roomId),1),d("p",I,"Tu Nombre: "+w(n.state.myId),1),d("p",{class:$(["text-sm",n.state.isConnected?"text-green-400":"text-yellow-400"])},w(n.state.status),3),d("div",ee," Conectado con: "+w(Object.keys(n.state.peers).filter(c=>n.state.peers[c]?.status==="connected").length)+" usuario(s) ",1)]),d("div",ne,[(D(!0),O(H,null,L(n.state.messages,(c,C)=>(D(),O("div",{key:C,class:$(["flex",c.senderId===n.state.myId?"justify-end":"justify-start"])},[d("div",{class:$(["max-w-xs lg:max-w-md p-3 rounded-lg",c.senderId===n.state.myId?"bg-blue-600":"bg-gray-700"])},[d("p",ae,w(c.senderId===n.state.myId?"Tú":c.senderName),1),d("p",te,w(c.text),1),d("p",oe,w(new Date(c.timestamp).toLocaleTimeString()),1)],2)],2))),128))],512),d("footer",se,[d("form",{onSubmit:E(n.sendMessage,["prevent"]),class:"flex items-center space-x-2"},[q(d("input",{"onUpdate:modelValue":e[0]||(e[0]=c=>n.newMessage=c),type:"text",placeholder:"Escribe un mensaje...",disabled:!n.state.isConnected,class:"flex-grow px-3 py-2 text-white bg-gray-700 border border-gray-600 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 disabled:opacity-50"},null,8,ie),[[W,n.newMessage]]),d("button",{type:"submit",disabled:!n.state.isConnected||Object.keys(n.state.peers).length===0,class:"px-4 py-2 font-bold text-white bg-blue-600 rounded-md hover:bg-blue-700 disabled:bg-gray-500 disabled:cursor-not-allowed"}," Enviar ",8,re)],32)])])}const be=K(Q,[["render",le]]);export{be as default};
