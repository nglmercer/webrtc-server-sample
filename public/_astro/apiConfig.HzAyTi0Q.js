class h{config;constructor(e={}){this.config={level:1,prefix:"ws-client",enableConsole:!0,enableTimestamps:!0,enableColors:!0,...e}}shouldLog(e){return e>=this.config.level&&this.config.enableConsole}formatMessage(e,t,o,n){let i=`${`[${this.config.enableTimestamps?new Date().toISOString():""}] ${this.config.prefix}:${e} [${t}]`} ${o}`;if(n!==void 0)try{i+=` | Data: ${JSON.stringify(n)}`}catch{i+=` | Data: ${n}`}return i}getConsoleMethod(e){switch(e){case 0:return console.debug||console.log;case 1:return console.info||console.log;case 2:return console.warn||console.log;case 3:return console.error||console.log;default:return console.log}}debug(e,t,o){if(this.shouldLog(0)){const n=this.formatMessage("DEBUG",e,t,o);this.getConsoleMethod(0)(n)}}info(e,t,o){if(this.shouldLog(1)){const n=this.formatMessage("INFO",e,t,o);this.getConsoleMethod(1)(n)}}warn(e,t,o){if(this.shouldLog(2)){const n=this.formatMessage("WARN",e,t,o);this.getConsoleMethod(2)(n)}}error(e,t,o){if(this.shouldLog(3)){const n=this.formatMessage("ERROR",e,t,o);this.getConsoleMethod(3)(n)}}performance(e,t,o){this.debug(`performance:${e}`,`Operation completed in ${t}ms`,{...o,duration:t,performanceLog:!0})}connection(e,t,o){this.info(`connection:${e}`,`Connection ${e}`,{...o,socketId:t,connectionEvent:!0})}updateConfig(e){this.config={...this.config,...e}}setDebug(e){this.config.level=e?0:1}}function u(a){return new h(a)}class m{ws=null;url;options;eventCallbacks={};anyCallbacks=[];isConnected=!1;reconnectAttempts=0;maxReconnectAttempts=5;reconnectDelay=1e3;reconnectDelayMax=5e3;randomizationFactor=.5;pendingCallbacks=new Map;callbackCounter=0;socketId;compressionEnabled=!1;currentTimeout=null;reconnectTimer=null;connectionTimeout=null;cleanupTimer=null;isReconnecting=!1;manualDisconnect=!1;logger;constructor(e,t={},o=!0){this.url=e,this.options={reconnection:!0,reconnectionAttempts:5,reconnectionDelay:1e3,reconnectionDelayMax:5e3,randomizationFactor:.5,timeout:2e4,...t},this.maxReconnectAttempts=this.options.reconnectionAttempts||5,this.reconnectDelay=this.options.reconnectionDelay||1e3,this.reconnectDelayMax=this.options.reconnectionDelayMax||5e3,this.randomizationFactor=this.options.randomizationFactor||.5,this.socketId=`ws-client-${Math.random().toString(36).substring(2,11)}`,this.logger=u({prefix:`ws-client-${this.socketId}`,level:o?0:1}),this.logger.info("client_created","WebSocket client created",{url:this.url,socketId:this.socketId,reconnection:this.options.reconnection,timeout:this.options.timeout}),this.cleanupTimer=setInterval(()=>{this.cleanupStaleCallbacks()},3e4),t.autoConnect!==!1&&(this.logger.debug("auto_connect","Auto-connecting client"),this.connect())}connect(){this.clearTimers(),this.manualDisconnect=!1;try{this.reconnectAttempts>0&&this.emit("reconnect_attempt",this.reconnectAttempts);let e=this.url.replace(/^http/,"ws");const t=new URLSearchParams;this.options.query&&Object.entries(this.options.query).forEach(([s,r])=>{t.append(s,r)}),this.options.auth&&t.append("auth",JSON.stringify(this.options.auth)),t.append("socketId",this.socketId),this.options.forceNew&&t.append("forceNew","true"),this.options.multiplex!==void 0&&t.append("multiplex",this.options.multiplex.toString());const o=t.toString();o&&(e+=(e.includes("?")?"&":"?")+o),this.ws=new WebSocket(e),this.setupEventListeners();const n=this.options.timeout||2e4;this.connectionTimeout=setTimeout(()=>{if(this.ws&&this.ws.readyState===WebSocket.CONNECTING){const s=new Error("Connection timeout");s.code="CONNECTION_TIMEOUT",s.type="TransportError",s.description=`Connection timeout after ${n}ms`,this.ws.close(1e3,"Connection timeout"),this.handleConnectionError(s)}},n)}catch(e){console.error("Error al conectar WebSocket:",e),this.handleConnectionError(e)}return this}setupEventListeners(){this.ws&&(this.ws.onopen=()=>{this.clearTimers(),this.isConnected=!0,this.isReconnecting&&this.reconnectAttempts>0&&this.emit("reconnect",this.reconnectAttempts),this.reconnectAttempts=0,this.isReconnecting=!1,this.emit("connect")},this.ws.onmessage=e=>{try{const t=JSON.parse(e.data);if(console.log("[WS-ADAPTER] Mensaje recibido:",t),t.event==="ping"&&this.emit("pong",...t.payload||[]),t.event==="callback-response"&&t.callbackId&&this.pendingCallbacks.has(t.callbackId)){console.log("[WS-ADAPTER] Procesando callback response:",t.callbackId,t.payload);const o=this.pendingCallbacks.get(t.callbackId);this.pendingCallbacks.delete(t.callbackId),clearTimeout(o.timeoutId);try{if(t.error){const n=new Error(t.error.message||"Server callback error");n.code=t.error.code||"SERVER_CALLBACK_ERROR",n.type="CallbackError",n.callbackId=t.callbackId,n.originalError=t.error,o.callback(n)}else o.callback(...t.payload||[])}catch(n){console.error("Error ejecutando callback:",n);const s=new Error("Callback execution failed");s.code="CALLBACK_EXECUTION_ERROR",s.type="CallbackError",s.callbackId=t.callbackId,s.originalError=n,s.event=o.event,this.emit("error",s)}return}t.event&&t.event!=="callback-response"&&(console.log("[WS-ADAPTER] Emitiendo evento:",t.event,t.payload),this.emit(t.event,...t.payload||[]))}catch(t){console.error("[WS-ADAPTER] Error parsing WebSocket message:",t);const o=new Error("Failed to parse WebSocket message");o.code="PARSE_ERROR",o.type="MessageError",o.originalError=t,o.rawMessage=e.data,o.timestamp=Date.now(),this.emit("error",o)}},this.ws.onclose=e=>{this.clearTimers(),this.isConnected=!1;let t=e.reason||this.getDisconnectReason(e.code);const o=e.wasClean;console.log(`[WS-ADAPTER] Connection closed: ${t} (code: ${e.code}, clean: ${o})`);const n={wasClean:o,code:e.code,reason:e.reason,timestamp:Date.now(),attempt:this.reconnectAttempts};this.emit("disconnect",t,n),!this.manualDisconnect&&this.shouldReconnectOnClose(e.code)&&this.scheduleReconnection()},this.ws.onerror=e=>{console.error("[WS-ADAPTER] WebSocket error:",e);const t=new Error("WebSocket connection error");t.code="WEBSOCKET_ERROR",t.type="TransportError",t.originalError=e,t.readyState=this.ws?.readyState,t.url=this.url,this.handleConnectionError(t)})}getDisconnectReason(e){switch(e){case 1e3:return"Normal closure";case 1001:return"Going away";case 1002:return"Protocol error";case 1003:return"Unsupported data";case 1005:return"No status received";case 1006:return"Abnormal closure";case 1007:return"Invalid frame payload data";case 1008:return"Policy violation";case 1009:return"Message too big";case 1010:return"Mandatory extension";case 1011:return"Internal server error";case 1015:return"TLS handshake failure";default:return`Connection closed (code: ${e})`}}shouldReconnectOnClose(e){return!(e===1e3||e===1001||e===1002||e===1003||e===1007||e===1008)}on(e,t){return this.eventCallbacks[e]||(this.eventCallbacks[e]=[]),this.eventCallbacks[e].push(t),this}once(e,t){const o=(...n)=>{this.off(e,o),t(...n)};return this.on(e,o)}off(e,t){if(!this.eventCallbacks[e])return this;if(t){const o=this.eventCallbacks[e].indexOf(t);o>-1&&this.eventCallbacks[e].splice(o,1)}else delete this.eventCallbacks[e];return this}onAny(e){return this.anyCallbacks.push(e),this}offAny(e){if(e){const t=this.anyCallbacks.indexOf(e);t>-1&&this.anyCallbacks.splice(t,1)}else this.anyCallbacks=[];return this}send(...e){return this.emit("message",...e),this}compress(e){return this.compressionEnabled=e,this}timeout(e){return this.currentTimeout=e,this}emit(e,...t){if(this.eventCallbacks[e]&&this.eventCallbacks[e].forEach(o=>{try{o(...t)}catch(n){console.error(`Error en callback del evento '${e}':`,n)}}),this.anyCallbacks.length>0&&this.anyCallbacks.forEach(o=>{try{o(e,...t)}catch(n){console.error(`Error en callback "any" del evento '${e}':`,n)}}),this.isConnected&&this.ws&&!this.isInternalEvent(e)){if(this.ws.readyState!==WebSocket.OPEN)return console.warn(`[WS-ADAPTER] Cannot send message '${e}': WebSocket is not in OPEN state (readyState: ${this.ws.readyState})`),(this.ws.readyState===WebSocket.CLOSED||this.ws.readyState===WebSocket.CLOSING)&&(this.isConnected=!1,this.ws.readyState===WebSocket.CLOSED&&this.emit("disconnect","transport close",{wasClean:!1,code:1006,reason:"WebSocket closed unexpectedly",timestamp:Date.now(),attempt:this.reconnectAttempts})),!1;try{const o={event:e,payload:t};this.compressionEnabled&&(o.compress=!0);const n=t[t.length-1];if(typeof n=="function"){const s=`cb_${++this.callbackCounter}`,r=this.currentTimeout||this.options.timeout||2e4;console.log("[WS-ADAPTER] Enviando mensaje con callback:",e,s,t.slice(0,-1));const i=setTimeout(()=>{this.handleCallbackTimeout(s,r)},r);this.pendingCallbacks.set(s,{callback:n,timeoutId:i,timestamp:Date.now(),event:e,timeout:r,retries:0}),o.payload=t.slice(0,-1),o.callbackId=s,this.currentTimeout=null}else console.log("[WS-ADAPTER] Enviando mensaje sin callback:",e,t);return this.ws.send(JSON.stringify(o)),!0}catch(o){if(console.error("Error al enviar mensaje:",o),o instanceof DOMException){console.warn("[WS-ADAPTER] DOMException caught - WebSocket may be closed, updating connection state"),this.isConnected=!1;const n=new Error("WebSocket connection lost during send operation");n.code="WEBSOCKET_SEND_ERROR",n.type="TransportError",n.originalError=o,n.readyState=this.ws?.readyState,this.emit("error",n)}return!1}}return!0}isInternalEvent(e){return["connect","disconnect","error","connect_error","reconnect","reconnect_attempt","reconnect_error","reconnect_failed","user-registered","userid-already-taken"].includes(e)}clearTimers(){this.reconnectTimer&&(clearTimeout(this.reconnectTimer),this.reconnectTimer=null),this.connectionTimeout&&(clearTimeout(this.connectionTimeout),this.connectionTimeout=null)}clearAllTimers(){this.clearTimers(),this.cleanupTimer&&(clearInterval(this.cleanupTimer),this.cleanupTimer=null)}handleConnectionError(e){this.isConnected=!1,this.clearTimers(),e&&typeof e=="object"&&(e.timestamp=Date.now(),e.attempt=this.reconnectAttempts,e.url=this.url,e.type||(e.type="TransportError"),e.code||(e.code="CONNECTION_ERROR")),this.isReconnecting&&this.reconnectAttempts>0?this.emit("reconnect_error",e):this.emit("connect_error",e),this.emit("error",e),this.scheduleReconnection()}scheduleReconnection(){if(this.manualDisconnect||this.options.reconnection===!1)return;if(this.reconnectAttempts>=this.maxReconnectAttempts){const t=new Error("Reconnection failed after maximum attempts");t.code="RECONNECT_FAILED",t.type="ReconnectionError",t.attempts=this.reconnectAttempts,t.maxAttempts=this.maxReconnectAttempts,this.emit("reconnect_failed",t),this.emit("error",t);return}const e=this.calculateReconnectionDelay();this.isReconnecting=!0,this.reconnectTimer=setTimeout(()=>{this.reconnectAttempts++,console.log(`[WS-ADAPTER] Reconnection attempt ${this.reconnectAttempts}/${this.maxReconnectAttempts} (delay: ${Math.round(e)}ms)`),this.connect()},e)}calculateReconnectionDelay(){const e=this.reconnectDelay,t=this.reconnectDelayMax,o=this.randomizationFactor;let n=e*Math.pow(2,this.reconnectAttempts);n=Math.min(n,t);const s=n*o*Math.random();return n=Math.random()<.5?n+s:n-s,n=Math.max(n,e*.1),Math.round(n)}handleCallbackTimeout(e,t){if(!this.pendingCallbacks.has(e))return;const o=this.pendingCallbacks.get(e);this.pendingCallbacks.delete(e);try{const n=new Error(`Callback timeout after ${t}ms`);n.code="CALLBACK_TIMEOUT",n.type="CallbackError",n.callbackId=e,n.event=o.event,n.timeout=t,n.timestamp=Date.now(),n.elapsedTime=Date.now()-o.timestamp,o.callback(n)}catch(n){console.error("[WS-ADAPTER] Error en callback timeout:",n);const s=new Error("Timeout callback execution failed");s.code="TIMEOUT_CALLBACK_EXECUTION_ERROR",s.type="CallbackError",s.callbackId=e,s.originalError=n,s.event=o.event,this.emit("error",s)}}cleanupStaleCallbacks(){const e=Date.now(),t=6e4,o=[];this.pendingCallbacks.forEach((n,s)=>{if(e-n.timestamp>t){clearTimeout(n.timeoutId),this.pendingCallbacks.delete(s),o.push(s);try{const r=new Error("Callback cleanup - too old");r.code="CALLBACK_STALE",r.type="CallbackError",r.callbackId=s,r.event=n.event,r.age=e-n.timestamp,r.maxAge=t,n.callback(r)}catch(r){console.error("[WS-ADAPTER] Error en cleanup de callback stale:",r);const i=new Error("Stale callback cleanup failed");i.code="STALE_CALLBACK_CLEANUP_ERROR",i.type="CallbackError",i.callbackId=s,i.originalError=r,this.emit("error",i)}}}),o.length>0&&console.log(`[WS-ADAPTER] Cleaned up ${o.length} stale callbacks:`,o)}cleanupPendingCallbacks(e,t){const o=Array.from(this.pendingCallbacks.entries()),n=[];if(o.forEach(([s,r])=>{clearTimeout(r.timeoutId);try{const i=new Error(t);i.code=e,i.type="CallbackError",i.callbackId=s,i.event=r.event,i.timestamp=Date.now(),i.pendingTime=Date.now()-r.timestamp,r.callback(i)}catch(i){console.error(`[WS-ADAPTER] Error in callback cleanup (${s}):`,i),n.push({callbackId:s,event:r.event,error:i})}}),this.pendingCallbacks.clear(),n.length>0){const s=new Error(`Failed to cleanup ${n.length} callbacks`);s.code="CALLBACK_CLEANUP_ERROR",s.type="CallbackError",s.cleanupErrors=n,this.emit("error",s)}console.log(`[WS-ADAPTER] Cleaned up ${o.length} pending callbacks (reason: ${t})`)}getCallbackStats(){const e=Date.now();let t=0,o=0;const n={},s={};this.pendingCallbacks.forEach(i=>{const c=e-i.timestamp;c>t&&(t=c),o+=c,n[i.event]=(n[i.event]||0)+1;const l=this.getTimeoutRange(i.timeout);s[l]=(s[l]||0)+1});const r=this.pendingCallbacks.size>0?o/this.pendingCallbacks.size:0;return{pending:this.pendingCallbacks.size,oldestAge:t,averageAge:r,byEvent:n,timeoutDistribution:s}}getTimeoutRange(e){return e<1e3?"<1s":e<5e3?"1-5s":e<1e4?"5-10s":e<3e4?"10-30s":">30s"}getReconnectionStats(){return{isReconnecting:this.isReconnecting,attempts:this.reconnectAttempts,maxAttempts:this.maxReconnectAttempts,nextDelay:this.isReconnecting?this.calculateReconnectionDelay():void 0,reconnectionEnabled:this.options.reconnection!==!1}}disconnect(){return this.manualDisconnect=!0,this.clearAllTimers(),this.ws&&(this.ws.close(1e3,"Client disconnect"),this.ws=null),this.isConnected=!1,this.isReconnecting=!1,this.reconnectAttempts=0,this.cleanupPendingCallbacks("SOCKET_DISCONNECTED","Socket disconnected"),this}get connected(){return this.isConnected}get disconnected(){return!this.isConnected}get id(){return this.socketId}clearCallbacks(e){let t=0;const o=[];return this.pendingCallbacks.forEach((n,s)=>{if(!e||n.event===e){clearTimeout(n.timeoutId),o.push(s);try{const r=new Error("Callback manually cleared");r.code="CALLBACK_CLEARED",r.type="CallbackError",r.callbackId=s,r.event=n.event,r.timestamp=Date.now(),n.callback(r),t++}catch(r){console.error(`[WS-ADAPTER] Error clearing callback ${s}:`,r)}}}),o.forEach(n=>{this.pendingCallbacks.delete(n)}),console.log(`[WS-ADAPTER] Manually cleared ${t} callbacks${e?` for event '${e}'`:""}`),t}getPendingCallbacks(){const e=Date.now(),t=[];return this.pendingCallbacks.forEach((o,n)=>{t.push({callbackId:n,event:o.event,age:e-o.timestamp,timeout:o.timeout,retries:o.retries})}),t.sort((o,n)=>n.age-o.age)}setCallbackLimits(e=1e3,t=3e5){const o=Date.now(),n=[];if(this.pendingCallbacks.forEach((s,r)=>{o-s.timestamp>t&&n.push(r)}),this.pendingCallbacks.size>e){const s=Array.from(this.pendingCallbacks.entries()).sort(([,i],[,c])=>i.timestamp-c.timestamp),r=this.pendingCallbacks.size-e;for(let i=0;i<r;i++)n.push(s[i][0])}n.forEach(s=>{const r=this.pendingCallbacks.get(s);if(r){clearTimeout(r.timeoutId),this.pendingCallbacks.delete(s);try{const i=new Error("Callback removed due to limits");i.code="CALLBACK_LIMIT_EXCEEDED",i.type="CallbackError",i.callbackId=s,i.event=r.event,r.callback(i)}catch(i){console.error(`[WS-ADAPTER] Error in limit cleanup for callback ${s}:`,i)}}}),n.length>0&&console.log(`[WS-ADAPTER] Removed ${n.length} callbacks due to limits (maxPending: ${e}, maxAge: ${t}ms)`)}}const d={host:"127.0.0.1",port:9001,protocol:"http",getFullUrl(){return`${this.protocol}://${this.host}:${this.port}`},update(a){Object.assign(this,a),console.log("API config updated:",this.getFullUrl())},proxy:void 0};export{m as S,d as a};
